% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}

\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
\else\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{eqparbox}


\addto\captionsenglish{\renewcommand{\figurename}{Fig. }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\SetupFloatingEnvironment{literal-block}{name=Listing }

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{3}


\title{Homomorphic Processor Documentation}
\date{Apr 26, 2016}
\release{0.1}
\author{Louis GERARD and Edouard SAMYN}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ch\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@cpf\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Contents:


\chapter{homomorphic-processor}
\label{index:homomorphic-processor}\label{index:welcome-to-homomorphic-processor-s-documentation}\label{index:foo-bar}

\section{datatypes package}
\label{datatypes::doc}\label{datatypes:datatypes-package}

\subsection{Subpackages}
\label{datatypes:subpackages}

\subsubsection{datatypes.bits package}
\label{datatypes.bits::doc}\label{datatypes.bits:datatypes-bits-package}

\paragraph{Subpackages}
\label{datatypes.bits:subpackages}

\subparagraph{datatypes.bits.errors package}
\label{datatypes.bits.errors:datatypes-bits-errors-package}\label{datatypes.bits.errors::doc}

\subparagraph{Submodules}
\label{datatypes.bits.errors:submodules}

\subparagraph{datatypes.bits.errors.BitwiseOperationError module}
\label{datatypes.bits.errors:module-datatypes.bits.errors.BitwiseOperationError}\label{datatypes.bits.errors:datatypes-bits-errors-bitwiseoperationerror-module}\index{datatypes.bits.errors.BitwiseOperationError (module)}\index{BitwiseOperationError}

\begin{fulllineitems}
\phantomsection\label{datatypes.bits.errors:datatypes.bits.errors.BitwiseOperationError.BitwiseOperationError}\pysiglinewithargsret{\strong{exception }\code{datatypes.bits.errors.BitwiseOperationError.}\bfcode{BitwiseOperationError}}{\emph{message}}{}
Bases: \code{exceptions.RuntimeError}

\end{fulllineitems}



\subparagraph{datatypes.bits.errors.InstantiationError module}
\label{datatypes.bits.errors:datatypes-bits-errors-instantiationerror-module}\label{datatypes.bits.errors:module-datatypes.bits.errors.InstantiationError}\index{datatypes.bits.errors.InstantiationError (module)}\index{InstantiationError}

\begin{fulllineitems}
\phantomsection\label{datatypes.bits.errors:datatypes.bits.errors.InstantiationError.InstantiationError}\pysiglinewithargsret{\strong{exception }\code{datatypes.bits.errors.InstantiationError.}\bfcode{InstantiationError}}{\emph{message}}{}
Bases: \code{exceptions.RuntimeError}

\end{fulllineitems}



\subparagraph{datatypes.bits.errors.OpNotAllowedError module}
\label{datatypes.bits.errors:datatypes-bits-errors-opnotallowederror-module}\label{datatypes.bits.errors:module-datatypes.bits.errors.OpNotAllowedError}\index{datatypes.bits.errors.OpNotAllowedError (module)}\index{OpNotAllowedError}

\begin{fulllineitems}
\phantomsection\label{datatypes.bits.errors:datatypes.bits.errors.OpNotAllowedError.OpNotAllowedError}\pysiglinewithargsret{\strong{exception }\code{datatypes.bits.errors.OpNotAllowedError.}\bfcode{OpNotAllowedError}}{\emph{message}}{}
Bases: \code{exceptions.RuntimeError}

\end{fulllineitems}



\paragraph{Submodules}
\label{datatypes.bits:submodules}

\paragraph{datatypes.bits.Bit module}
\label{datatypes.bits:module-datatypes.bits.Bit}\label{datatypes.bits:datatypes-bits-bit-module}\index{datatypes.bits.Bit (module)}\index{Bit (class in datatypes.bits.Bit)}

\begin{fulllineitems}
\phantomsection\label{datatypes.bits:datatypes.bits.Bit.Bit}\pysigline{\strong{class }\code{datatypes.bits.Bit.}\bfcode{Bit}}
General purpose bit, might be encrypted or not.
This is an abstract class and therefore might not be instantiated
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\textbf{\texttt{InstantiationError}} -- if called.

\end{description}\end{quote}
\index{AND() (datatypes.bits.Bit.Bit method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.bits:datatypes.bits.Bit.Bit.AND}\pysiglinewithargsret{\bfcode{AND}}{\emph{other}}{}
This method should be overridden in subclasses to perform a logical AND operation between two bits.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\textbf{\texttt{OpNotAllowedError}} -- if called

\end{description}\end{quote}

\end{fulllineitems}

\index{NOT() (datatypes.bits.Bit.Bit method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.bits:datatypes.bits.Bit.Bit.NOT}\pysiglinewithargsret{\bfcode{NOT}}{}{}
This method should be overridden in subclasses to perform a logical NOT operation on self.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\textbf{\texttt{OpNotAllowedError}} -- if called

\end{description}\end{quote}

\end{fulllineitems}

\index{OR() (datatypes.bits.Bit.Bit method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.bits:datatypes.bits.Bit.Bit.OR}\pysiglinewithargsret{\bfcode{OR}}{\emph{other}}{}
This method should be overridden in subclasses to perform a logical OR operation between two bits.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\textbf{\texttt{OpNotAllowedError}} -- if called

\end{description}\end{quote}

\end{fulllineitems}

\index{XOR() (datatypes.bits.Bit.Bit method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.bits:datatypes.bits.Bit.Bit.XOR}\pysiglinewithargsret{\bfcode{XOR}}{\emph{other}}{}
This method should be overridden in subclasses to perform a logical XOR operation between two bits.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\textbf{\texttt{OpNotAllowedError}} -- if called

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_add\_\_() (datatypes.bits.Bit.Bit method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.bits:datatypes.bits.Bit.Bit.__add__}\pysiglinewithargsret{\bfcode{\_\_add\_\_}}{\emph{other}}{}
This method just calls the OR operation
We overrode this operator to be able to write logic equations more easily

\end{fulllineitems}

\index{\_\_and\_\_() (datatypes.bits.Bit.Bit method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.bits:datatypes.bits.Bit.Bit.__and__}\pysiglinewithargsret{\bfcode{\_\_and\_\_}}{\emph{other}}{}
This method just calls the AND operation
We overrode this operator to be able to write logic equations more easily

\end{fulllineitems}

\index{\_\_invert\_\_() (datatypes.bits.Bit.Bit method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.bits:datatypes.bits.Bit.Bit.__invert__}\pysiglinewithargsret{\bfcode{\_\_invert\_\_}}{}{}
This method just calls the NOT operation
We overrode this operator to be able to write logic equations more easily

\end{fulllineitems}

\index{\_\_mul\_\_() (datatypes.bits.Bit.Bit method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.bits:datatypes.bits.Bit.Bit.__mul__}\pysiglinewithargsret{\bfcode{\_\_mul\_\_}}{\emph{other}}{}
This method just calls the AND operation
We overrode this operator to be able to write logic equations more easily

\end{fulllineitems}

\index{\_\_neg\_\_() (datatypes.bits.Bit.Bit method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.bits:datatypes.bits.Bit.Bit.__neg__}\pysiglinewithargsret{\bfcode{\_\_neg\_\_}}{}{}
This method just calls the NOT operation
We overrode this operator to be able to write logic equations more easily

\end{fulllineitems}

\index{\_\_or\_\_() (datatypes.bits.Bit.Bit method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.bits:datatypes.bits.Bit.Bit.__or__}\pysiglinewithargsret{\bfcode{\_\_or\_\_}}{\emph{other}}{}
This method just calls the OR operation
We overrode this operator to be able to write logic equations more easily

\end{fulllineitems}

\index{\_\_xor\_\_() (datatypes.bits.Bit.Bit method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.bits:datatypes.bits.Bit.Bit.__xor__}\pysiglinewithargsret{\bfcode{\_\_xor\_\_}}{\emph{other}}{}
This method just calls the XOR operation
We overrode this operator to be able to write logic equations more easily

\end{fulllineitems}

\index{debug\_\_printAsBoolean() (datatypes.bits.Bit.Bit method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.bits:datatypes.bits.Bit.Bit.debug__printAsBoolean}\pysiglinewithargsret{\bfcode{debug\_\_printAsBoolean}}{}{}
This method is for debug purposes only, it will reveal the Boolean value in the bit
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\textbf{\texttt{OpNotAllowedError}} -- if called

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{CryptoBit (class in datatypes.bits.Bit)}

\begin{fulllineitems}
\phantomsection\label{datatypes.bits:datatypes.bits.Bit.CryptoBit}\pysiglinewithargsret{\strong{class }\code{datatypes.bits.Bit.}\bfcode{CryptoBit}}{\emph{value=False}, \emph{verbose=False}}{}
Bases: {\hyperref[datatypes.bits:datatypes.bits.Bit.Bit]{\crossref{\code{datatypes.bits.Bit.Bit}}}}

Emulated homomorphic bit, we forbid ourselves to read the bit value.
Upon creation, the apparent value of the bit will be random.
The plain value is stored in the \_\_bit member.

:param value:(optional) Defines the value of the bit, defaults to False
:param verbose:(optional) Defines whether or not the bit will print a message upon refresh, defaults to False
\index{AND() (datatypes.bits.Bit.CryptoBit method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.bits:datatypes.bits.Bit.CryptoBit.AND}\pysiglinewithargsret{\bfcode{AND}}{\emph{other}}{}
Performs a logical AND operation between self and other
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{other}} (\emph{\texttt{PlainBit or CryptoBit}}) -- RightOperand

\item[{Returns}] \leavevmode
A bit containing the result of the AND operation

\item[{Return type}] \leavevmode
{\hyperref[datatypes.bits:datatypes.bits.Bit.CryptoBit]{\crossref{CryptoBit}}}

\item[{Raises}] \leavevmode
\textbf{\texttt{BitwiseOperationError}} -- if the right operand is not a Bit

\end{description}\end{quote}

\end{fulllineitems}

\index{NOT() (datatypes.bits.Bit.CryptoBit method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.bits:datatypes.bits.Bit.CryptoBit.NOT}\pysiglinewithargsret{\bfcode{NOT}}{}{}
Performs a logical NOT operation on self
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A bit containing the result of the NOT operation

\item[{Return type}] \leavevmode
{\hyperref[datatypes.bits:datatypes.bits.Bit.CryptoBit]{\crossref{CryptoBit}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{OR() (datatypes.bits.Bit.CryptoBit method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.bits:datatypes.bits.Bit.CryptoBit.OR}\pysiglinewithargsret{\bfcode{OR}}{\emph{other}}{}
Performs a logical OR operation between self and other
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{other}} (\emph{\texttt{PlainBit or CryptoBit}}) -- RightOperand

\item[{Returns}] \leavevmode
A bit containing the result of the OR operation

\item[{Return type}] \leavevmode
{\hyperref[datatypes.bits:datatypes.bits.Bit.CryptoBit]{\crossref{CryptoBit}}}

\item[{Raises}] \leavevmode
\textbf{\texttt{BitwiseOperationError}} -- if the right operand is not a Bit

\end{description}\end{quote}

\end{fulllineitems}

\index{XOR() (datatypes.bits.Bit.CryptoBit method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.bits:datatypes.bits.Bit.CryptoBit.XOR}\pysiglinewithargsret{\bfcode{XOR}}{\emph{other}}{}
Performs a logical XOR operation between self and other
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{other}} (\emph{\texttt{PlainBit or CryptoBit}}) -- RightOperand

\item[{Returns}] \leavevmode
A bit containing the result of the XOR operation

\item[{Return type}] \leavevmode
{\hyperref[datatypes.bits:datatypes.bits.Bit.CryptoBit]{\crossref{CryptoBit}}}

\item[{Raises}] \leavevmode
\textbf{\texttt{BitwiseOperationError}} -- if the right operand is not a Bit

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_eq\_\_() (datatypes.bits.Bit.CryptoBit method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.bits:datatypes.bits.Bit.CryptoBit.__eq__}\pysiglinewithargsret{\bfcode{\_\_eq\_\_}}{\emph{other}}{}
Test if two bits are Equals, however since two Cryptobits cannot be compared directly, this function always returns an exception
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\textbf{\texttt{OpNotAllowedError}} -- if other is not of type PlainBit

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_repr\_\_() (datatypes.bits.Bit.CryptoBit method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.bits:datatypes.bits.Bit.CryptoBit.__repr__}\pysiglinewithargsret{\bfcode{\_\_repr\_\_}}{}{}
Return representation of Crypto

Note that this value is not the real value but a random value, so you should not rely on it
:returns: 1 if bit is set to True, 0 otherwise

\end{fulllineitems}

\index{debug\_\_printAsBoolean() (datatypes.bits.Bit.CryptoBit method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.bits:datatypes.bits.Bit.CryptoBit.debug__printAsBoolean}\pysiglinewithargsret{\bfcode{debug\_\_printAsBoolean}}{}{}
This method is for debug purposes only, it will reveal the Boolean value in the bit
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Boolean value of bit

\item[{Return type}] \leavevmode
Boolean

\end{description}\end{quote}

\end{fulllineitems}

\index{decrypt() (datatypes.bits.Bit.CryptoBit method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.bits:datatypes.bits.Bit.CryptoBit.decrypt}\pysiglinewithargsret{\bfcode{decrypt}}{}{}
Decrypt the CryptoBit
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
PlainBit containing the value of the CryptoBit

\item[{Return type}] \leavevmode
PlainBit

\end{description}\end{quote}

\end{fulllineitems}

\index{refresh() (datatypes.bits.Bit.CryptoBit method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.bits:datatypes.bits.Bit.CryptoBit.refresh}\pysiglinewithargsret{\bfcode{refresh}}{}{}
Resets the bit's noise, if the bit's verbose attribute is set, then it will print a message

\end{fulllineitems}

\index{setNoise() (datatypes.bits.Bit.CryptoBit method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.bits:datatypes.bits.Bit.CryptoBit.setNoise}\pysiglinewithargsret{\bfcode{setNoise}}{\emph{value=0}}{}
Sets the bit's noise, if the noise is above the threshold, then it will trigger a refresh
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{value}} (\emph{\texttt{int}}) -- The value that should be set, defaults to 0

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{PlainBit (class in datatypes.bits.Bit)}

\begin{fulllineitems}
\phantomsection\label{datatypes.bits:datatypes.bits.Bit.PlainBit}\pysiglinewithargsret{\strong{class }\code{datatypes.bits.Bit.}\bfcode{PlainBit}}{\emph{value=False}}{}
Bases: {\hyperref[datatypes.bits:datatypes.bits.Bit.Bit]{\crossref{\code{datatypes.bits.Bit.Bit}}}}

This class represents a bit which is not encrypted
Its goal is just to wrap a boolean and allow us to do operation with CryptoBits
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{value}} (\emph{\texttt{Boolean}}) -- Defines the value of the bit, defaults to False

\end{description}\end{quote}
\index{AND() (datatypes.bits.Bit.PlainBit method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.bits:datatypes.bits.Bit.PlainBit.AND}\pysiglinewithargsret{\bfcode{AND}}{\emph{other}}{}
Performs a logical AND operation between self and other
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{other}} (\emph{\texttt{PlainBit or CryptoBit}}) -- RightOperand

\item[{Returns}] \leavevmode
A bit containing the result of the AND operation

\item[{Return type}] \leavevmode
PlainBit if right operand is PlainBit, CryptoBit if right operand is CryptoBit

\item[{Raises}] \leavevmode
\textbf{\texttt{BitwiseOperationError}} -- if the right operand is not a Bit

\end{description}\end{quote}

\end{fulllineitems}

\index{NOT() (datatypes.bits.Bit.PlainBit method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.bits:datatypes.bits.Bit.PlainBit.NOT}\pysiglinewithargsret{\bfcode{NOT}}{}{}
Performs a logical NOT operation on self
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A bit containing the result of the NOT operation

\item[{Return type}] \leavevmode
PlainBit

\end{description}\end{quote}

\end{fulllineitems}

\index{OR() (datatypes.bits.Bit.PlainBit method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.bits:datatypes.bits.Bit.PlainBit.OR}\pysiglinewithargsret{\bfcode{OR}}{\emph{other}}{}
Performs a logical OR operation between self and other
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{other}} (\emph{\texttt{PlainBit or CryptoBit}}) -- RightOperand

\item[{Returns}] \leavevmode
A bit containing the result of the OR operation

\item[{Return type}] \leavevmode
PlainBit if right operand is PlainBit, CryptoBit if right operand is CryptoBit

\item[{Raises}] \leavevmode
\textbf{\texttt{BitwiseOperationError}} -- if the right operand is not a Bit

\end{description}\end{quote}

\end{fulllineitems}

\index{XOR() (datatypes.bits.Bit.PlainBit method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.bits:datatypes.bits.Bit.PlainBit.XOR}\pysiglinewithargsret{\bfcode{XOR}}{\emph{other}}{}
Performs a logical XOR operation between self and other
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{other}} (\emph{\texttt{PlainBit or CryptoBit}}) -- RightOperand

\item[{Returns}] \leavevmode
A bit containing the result of the XOR operation

\item[{Return type}] \leavevmode
PlainBit if right operand is PlainBit, CryptoBit if right operand is CryptoBit

\item[{Raises}] \leavevmode
\textbf{\texttt{BitwiseOperationError}} -- if the right operand is not a Bit

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_eq\_\_() (datatypes.bits.Bit.PlainBit method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.bits:datatypes.bits.Bit.PlainBit.__eq__}\pysiglinewithargsret{\bfcode{\_\_eq\_\_}}{\emph{other}}{}
Test if two bits are Equals
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{other}} (\emph{\texttt{PlainBit}}) -- Bit to compare

\item[{Returns}] \leavevmode
True if bits are equal, False otherwise

\item[{Return type}] \leavevmode
Boolean

\item[{Raises}] \leavevmode
\textbf{\texttt{OpNotAllowedError}} -- if other is not of type PlainBit

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_repr\_\_() (datatypes.bits.Bit.PlainBit method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.bits:datatypes.bits.Bit.PlainBit.__repr__}\pysiglinewithargsret{\bfcode{\_\_repr\_\_}}{}{}
Return representation of Plain Bit
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
1 if bit is set to True, 0 otherwise

\end{description}\end{quote}

\end{fulllineitems}

\index{debug\_\_printAsBoolean() (datatypes.bits.Bit.PlainBit method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.bits:datatypes.bits.Bit.PlainBit.debug__printAsBoolean}\pysiglinewithargsret{\bfcode{debug\_\_printAsBoolean}}{}{}
This method is for debug purposes only, it will reveal the Boolean value in the bit
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Boolean value of bit

\item[{Return type}] \leavevmode
Boolean

\end{description}\end{quote}

\end{fulllineitems}

\index{encrypt() (datatypes.bits.Bit.PlainBit method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.bits:datatypes.bits.Bit.PlainBit.encrypt}\pysiglinewithargsret{\bfcode{encrypt}}{}{}
Encrypts the PlainBit
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
CryptoBit containing the value of the PlainBit

\item[{Return type}] \leavevmode
{\hyperref[datatypes.bits:datatypes.bits.Bit.CryptoBit]{\crossref{CryptoBit}}}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{datatypes.integers package}
\label{datatypes.integers:datatypes-integers-package}\label{datatypes.integers::doc}

\paragraph{Subpackages}
\label{datatypes.integers:subpackages}

\subparagraph{datatypes.integers.error package}
\label{datatypes.integers.error::doc}\label{datatypes.integers.error:datatypes-integers-error-package}

\subparagraph{Submodules}
\label{datatypes.integers.error:submodules}

\subparagraph{datatypes.integers.error.BadRightOperand module}
\label{datatypes.integers.error:module-datatypes.integers.error.BadRightOperand}\label{datatypes.integers.error:datatypes-integers-error-badrightoperand-module}\index{datatypes.integers.error.BadRightOperand (module)}\index{BadRightOperand}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers.error:datatypes.integers.error.BadRightOperand.BadRightOperand}\pysigline{\strong{exception }\code{datatypes.integers.error.BadRightOperand.}\bfcode{BadRightOperand}}
Bases: \code{exceptions.RuntimeError}

\end{fulllineitems}



\subparagraph{datatypes.integers.error.OverflowError module}
\label{datatypes.integers.error:datatypes-integers-error-overflowerror-module}\label{datatypes.integers.error:module-datatypes.integers.error.OverflowError}\index{datatypes.integers.error.OverflowError (module)}\index{OverflowError}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers.error:datatypes.integers.error.OverflowError.OverflowError}\pysiglinewithargsret{\strong{exception }\code{datatypes.integers.error.OverflowError.}\bfcode{OverflowError}}{\emph{message}}{}
Bases: \code{exceptions.RuntimeError}

\end{fulllineitems}



\paragraph{Submodules}
\label{datatypes.integers:submodules}

\paragraph{datatypes.integers.Int8 module}
\label{datatypes.integers:module-datatypes.integers.Int8}\label{datatypes.integers:datatypes-integers-int8-module}\index{datatypes.integers.Int8 (module)}\index{Int8 (class in datatypes.integers.Int8)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.Int8.Int8}\pysiglinewithargsret{\strong{class }\code{datatypes.integers.Int8.}\bfcode{Int8}}{\emph{value=0}, \emph{bits=None}, \emph{randomize=False}}{}
Signed integer made from an array of 8 Bits. (from -128 to 127)
the representation is in two's complement
We chose a convention for our arrays of bits :
when we initiate a byte, the first bit of the array is the Most Significant Bit.
The last one is the Least Significant Bit.
Thus, bits{[}0{]} = MSB, bits{[}bits.length(){]} = LSB
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\textbf{\texttt{InstantiationError}} -- if the array is too long/short

\end{description}\end{quote}
\index{\_\_abs\_\_() (datatypes.integers.Int8.Int8 method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.Int8.Int8.__abs__}\pysiglinewithargsret{\bfcode{\_\_abs\_\_}}{}{}
Returns the absolute value. Since our integers are coded in two's complement, absolute value of -128 cannot be represented. However if self equals -128 the result will have its testOverflow bit set to
indicate that an overflowError has occurred.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
the absolute value, except for -128 for which it returns 0.

\item[{Return type}] \leavevmode
{\hyperref[datatypes.integers:datatypes.integers.Int8.Int8]{\crossref{Int8}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_add\_\_() (datatypes.integers.Int8.Int8 method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.Int8.Int8.__add__}\pysiglinewithargsret{\bfcode{\_\_add\_\_}}{\emph{other}}{}
This method will add 2 Int8.
We override this operator to be able to write operations more easily
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{other}} ({\hyperref[datatypes.integers:datatypes.integers.Int8.Int8]{\crossref{\emph{\texttt{Int8}}}}}) -- Right Operand

\item[{Returns}] \leavevmode
the sum of the two Int8

\item[{Return type}] \leavevmode
{\hyperref[datatypes.integers:datatypes.integers.Int8.Int8]{\crossref{Int8}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_and\_\_() (datatypes.integers.Int8.Int8 method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.Int8.Int8.__and__}\pysiglinewithargsret{\bfcode{\_\_and\_\_}}{\emph{other}}{}
bitwise AND operation, returns an Int8
We override this operator to be able to write operations more easily
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{other}} ({\hyperref[datatypes.integers:datatypes.integers.Int8.Int8]{\crossref{\emph{\texttt{Int8}}}}}) -- Right Operand

\item[{Returns}] \leavevmode
bitwise AND operation, returns an Int8

\item[{Return type}] \leavevmode
{\hyperref[datatypes.integers:datatypes.integers.Int8.Int8]{\crossref{Int8}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_div\_\_() (datatypes.integers.Int8.Int8 method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.Int8.Int8.__div__}\pysiglinewithargsret{\bfcode{\_\_div\_\_}}{\emph{other}}{}
This method will divide 2 Int8.
We override this operator to be able to write operations more easily
DIVISION IS ROUNDED TOWARDS 0 since it uses the division from the absolutes value of the arguments given.
This means that there might be an isssue when using -128 as an operand, cf \_\_abs\_\_ function
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{other}} ({\hyperref[datatypes.integers:datatypes.integers.Int8.Int8]{\crossref{\emph{\texttt{Int8}}}}}) -- Right Operand

\item[{Returns}] \leavevmode
the result of division of the two Int8

\item[{Return type}] \leavevmode
{\hyperref[datatypes.integers:datatypes.integers.Int8.Int8]{\crossref{Int8}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_eq\_\_() (datatypes.integers.Int8.Int8 method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.Int8.Int8.__eq__}\pysiglinewithargsret{\bfcode{\_\_eq\_\_}}{\emph{other}}{}
test if two Int8 are equal
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{other}} ({\hyperref[datatypes.integers:datatypes.integers.Int8.Int8]{\crossref{\emph{\texttt{Int8}}}}}) -- Int8 to compare

\item[{Returns}] \leavevmode
True or False, in form of a CryptoBit or a PlainBit

\item[{Return type}] \leavevmode
CryptoBit or PlainBit

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_ge\_\_() (datatypes.integers.Int8.Int8 method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.Int8.Int8.__ge__}\pysiglinewithargsret{\bfcode{\_\_ge\_\_}}{\emph{other}}{}
test if an Int8 is greater or equal than/to another one
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{other}} ({\hyperref[datatypes.integers:datatypes.integers.Int8.Int8]{\crossref{\emph{\texttt{Int8}}}}}) -- Int8 to compare

\item[{Returns}] \leavevmode
CryptoBit or PlainBit (true or false)

\item[{Return type}] \leavevmode
CryptoBit or PlainBit

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_gt\_\_() (datatypes.integers.Int8.Int8 method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.Int8.Int8.__gt__}\pysiglinewithargsret{\bfcode{\_\_gt\_\_}}{\emph{other}}{}
test if an Int8 is greater than another one
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{other}} ({\hyperref[datatypes.integers:datatypes.integers.Int8.Int8]{\crossref{\emph{\texttt{Int8}}}}}) -- Int8 to compare

\item[{Returns}] \leavevmode
CryptoBit or PlainBit (true or false)

\item[{Return type}] \leavevmode
CryptoBit or PlainBit

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_invert\_\_() (datatypes.integers.Int8.Int8 method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.Int8.Int8.__invert__}\pysiglinewithargsret{\bfcode{\_\_invert\_\_}}{}{}
returns the one's complement Int8
We override this operator to be able to write operations more easily
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
the one's complement Int8

\item[{Return type}] \leavevmode
{\hyperref[datatypes.integers:datatypes.integers.Int8.Int8]{\crossref{Int8}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_le\_\_() (datatypes.integers.Int8.Int8 method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.Int8.Int8.__le__}\pysiglinewithargsret{\bfcode{\_\_le\_\_}}{\emph{other}}{}
test if an Int8 is lesser or equal than/to another one
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{other}} ({\hyperref[datatypes.integers:datatypes.integers.Int8.Int8]{\crossref{\emph{\texttt{Int8}}}}}) -- Int8 to compare

\item[{Returns}] \leavevmode
CryptoBit or PlainBit (true or false)

\item[{Return type}] \leavevmode
CryptoBit or PlainBit

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_len\_\_() (datatypes.integers.Int8.Int8 method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.Int8.Int8.__len__}\pysiglinewithargsret{\bfcode{\_\_len\_\_}}{}{}
returns the length of the array of bits of an Int8 (which is always 8)
We override this operator to be able to write operations more easily
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
an integer, the size of the array of bits of Int8 (which is 8)

\item[{Return type}] \leavevmode
integer

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_lshift\_\_() (datatypes.integers.Int8.Int8 method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.Int8.Int8.__lshift__}\pysiglinewithargsret{\bfcode{\_\_lshift\_\_}}{\emph{other}}{}
returns an Int8 that its bits were shifted to the left
We override this operator to be able to write operations more easily
Note that this operation performs an arithmetic shift and not a binary shift
This means that the sign bit is ignored by the operation, and it will not be shifted as a consequence
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{other}} (\emph{\texttt{integer}}) -- integer to know how much we shift

\item[{Returns}] \leavevmode
an Int8, its bits were shifted to the left

\item[{Return type}] \leavevmode
{\hyperref[datatypes.integers:datatypes.integers.Int8.Int8]{\crossref{Int8}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_lt\_\_() (datatypes.integers.Int8.Int8 method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.Int8.Int8.__lt__}\pysiglinewithargsret{\bfcode{\_\_lt\_\_}}{\emph{other}}{}
test if an Int8 is lesser than another one
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{other}} ({\hyperref[datatypes.integers:datatypes.integers.Int8.Int8]{\crossref{\emph{\texttt{Int8}}}}}) -- Int8 to compare

\item[{Returns}] \leavevmode
CryptoBit or PlainBit (true or false)

\item[{Return type}] \leavevmode
CryptoBit or PlainBit

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_mod\_\_() (datatypes.integers.Int8.Int8 method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.Int8.Int8.__mod__}\pysiglinewithargsret{\bfcode{\_\_mod\_\_}}{\emph{other}}{}
This method will return the remainder of the division between 2 Int8.
We override this operator to be able to write operations more easily
As a convention the result will be positive and will be the rest from the euclidian division of the absolute values of the two arguments
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{other}} ({\hyperref[datatypes.integers:datatypes.integers.Int8.Int8]{\crossref{\emph{\texttt{Int8}}}}}) -- Right Operand

\item[{Returns}] \leavevmode
the remainder of the division between two Int8

\item[{Return type}] \leavevmode
{\hyperref[datatypes.integers:datatypes.integers.Int8.Int8]{\crossref{Int8}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_neg\_\_() (datatypes.integers.Int8.Int8 method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.Int8.Int8.__neg__}\pysiglinewithargsret{\bfcode{\_\_neg\_\_}}{}{}
returns the opposite Int8
We override this operator to be able to write operations more easily
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
opposite Int8, except for -128

\item[{Return type}] \leavevmode
{\hyperref[datatypes.integers:datatypes.integers.Int8.Int8]{\crossref{Int8}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_or\_\_() (datatypes.integers.Int8.Int8 method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.Int8.Int8.__or__}\pysiglinewithargsret{\bfcode{\_\_or\_\_}}{\emph{other}}{}
bitwise OR operation, returns an Int8
We override this operator to be able to write operations more easily
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{other}} ({\hyperref[datatypes.integers:datatypes.integers.Int8.Int8]{\crossref{\emph{\texttt{Int8}}}}}) -- Right Operand

\item[{Returns}] \leavevmode
bitwise OR operation, returns an Int8

\item[{Return type}] \leavevmode
{\hyperref[datatypes.integers:datatypes.integers.Int8.Int8]{\crossref{Int8}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_repr\_\_() (datatypes.integers.Int8.Int8 method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.Int8.Int8.__repr__}\pysiglinewithargsret{\bfcode{\_\_repr\_\_}}{}{}
Return representation of Int8
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
integer, the value of the Int8

\item[{Return type}] \leavevmode
integer

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_rshift\_\_() (datatypes.integers.Int8.Int8 method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.Int8.Int8.__rshift__}\pysiglinewithargsret{\bfcode{\_\_rshift\_\_}}{\emph{other}}{}
returns an Int8 that its bits were shifted to the right
We override this operator to be able to write operations more easily
Note that this operation performs an arithmetic shift and not a binary shift
This means that the sign bit is ignored by the operation, and it will not be shifted as a consequence
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{other}} (\emph{\texttt{integer}}) -- integer to know how much we shift

\item[{Returns}] \leavevmode
an Int8, its bits were shifted to the right

\item[{Return type}] \leavevmode
{\hyperref[datatypes.integers:datatypes.integers.Int8.Int8]{\crossref{Int8}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_sub\_\_() (datatypes.integers.Int8.Int8 method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.Int8.Int8.__sub__}\pysiglinewithargsret{\bfcode{\_\_sub\_\_}}{\emph{other}}{}
This method will substract 2 Int8.
We override this operator to be able to write operations more easily
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{other}} ({\hyperref[datatypes.integers:datatypes.integers.Int8.Int8]{\crossref{\emph{\texttt{Int8}}}}}) -- Right Operand

\item[{Returns}] \leavevmode
the difference of the two Int8

\item[{Return type}] \leavevmode
{\hyperref[datatypes.integers:datatypes.integers.Int8.Int8]{\crossref{Int8}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_xor\_\_() (datatypes.integers.Int8.Int8 method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.Int8.Int8.__xor__}\pysiglinewithargsret{\bfcode{\_\_xor\_\_}}{\emph{other}}{}
bitwise XOR operation, returns an Int8
We override this operator to be able to write operations more easily
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{other}} ({\hyperref[datatypes.integers:datatypes.integers.Int8.Int8]{\crossref{\emph{\texttt{Int8}}}}}) -- Right Operand

\item[{Returns}] \leavevmode
bitwise XOR operation, returns an Int8

\item[{Return type}] \leavevmode
{\hyperref[datatypes.integers:datatypes.integers.Int8.Int8]{\crossref{Int8}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{debug\_showValue() (datatypes.integers.Int8.Int8 method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.Int8.Int8.debug_showValue}\pysiglinewithargsret{\bfcode{debug\_showValue}}{}{}
This method is for debug purposes only, it will reveal the integer value of the Int8
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
an integer, the value of the Int8

\item[{Return type}] \leavevmode
integer

\end{description}\end{quote}

\end{fulllineitems}

\index{decrypt() (datatypes.integers.Int8.Int8 method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.Int8.Int8.decrypt}\pysiglinewithargsret{\bfcode{decrypt}}{}{}
This method makes every CryptoBit into PlainBit

\end{fulllineitems}

\index{encrypt() (datatypes.integers.Int8.Int8 method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.Int8.Int8.encrypt}\pysiglinewithargsret{\bfcode{encrypt}}{}{}
This method makes every PlainBit into CryptoBit

\end{fulllineitems}

\index{toUInt8() (datatypes.integers.Int8.Int8 method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.Int8.Int8.toUInt8}\pysiglinewithargsret{\bfcode{toUInt8}}{}{}
returns the abs value of integer as Unisgned Integer (UInt8)
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
abs value of integer as UInt8

\item[{Return type}] \leavevmode
{\hyperref[datatypes.integers:datatypes.integers.UInt8.UInt8]{\crossref{UInt8}}}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\paragraph{datatypes.integers.UInt module}
\label{datatypes.integers:datatypes-integers-uint-module}\label{datatypes.integers:module-datatypes.integers.UInt}\index{datatypes.integers.UInt (module)}\index{UInt (class in datatypes.integers.UInt)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.UInt.UInt}\pysiglinewithargsret{\strong{class }\code{datatypes.integers.UInt.}\bfcode{UInt}}{\emph{value=0}, \emph{ints=None}, \emph{fixedSize=None}, \emph{randomize=False}}{}
Unsigned integer made from an array of UInt8s.
We chose a convention for our arrays of bits :
when we initiate a byte, the first bit of the array is the Most Significant Bit.
The last one is the Least Significant Bit.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\textbf{\texttt{InstantiationError}} -- if the array is too long/short

\end{description}\end{quote}
\index{\_\_abs\_\_() (datatypes.integers.UInt.UInt method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.UInt.UInt.__abs__}\pysiglinewithargsret{\bfcode{\_\_abs\_\_}}{}{}
return the absolute value which is itself
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
the absolute value (itself)

\item[{Return type}] \leavevmode
{\hyperref[datatypes.integers:module\string-datatypes.integers.UInt]{\crossref{UInt}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_add\_\_() (datatypes.integers.UInt.UInt method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.UInt.UInt.__add__}\pysiglinewithargsret{\bfcode{\_\_add\_\_}}{\emph{other}}{}
We wanted to append another 8-bit word if an overflow was detected, however we realized it could weaken the encryption.
Therefore, we decided to return both the incorrect result and the carryOut bit to be properly handled by the user once decrypted.
There may be some error in this function. When we add two UInt of different sizes, or when we add an UInt of value zero.

/!Be aware of this potential error
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{other}} -- UInt

\item[{Returns}] \leavevmode
The sum of two UInts

\item[{Return type}] \leavevmode
{\hyperref[datatypes.integers:module\string-datatypes.integers.UInt]{\crossref{UInt}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_eq\_\_() (datatypes.integers.UInt.UInt method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.UInt.UInt.__eq__}\pysiglinewithargsret{\bfcode{\_\_eq\_\_}}{\emph{other}}{}
test if two UInts are equal
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{other}} ({\hyperref[datatypes.integers:module\string-datatypes.integers.UInt]{\crossref{\emph{\texttt{UInt}}}}}) -- UInt to compare

\item[{Returns}] \leavevmode
True or False, in form of a CryptoBit or a PlainBit

\item[{Return type}] \leavevmode
CryptoBit or PlainBit

\item[{Raises}] \leavevmode
BadRightOperand

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_len\_\_() (datatypes.integers.UInt.UInt method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.UInt.UInt.__len__}\pysiglinewithargsret{\bfcode{\_\_len\_\_}}{}{}
returns the length of the array of UInt8s
We override this operator to be able to write operations more easily
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
an integer, the size of the array of UInt8s

\item[{Return type}] \leavevmode
integer

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_sub\_\_() (datatypes.integers.UInt.UInt method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.UInt.UInt.__sub__}\pysiglinewithargsret{\bfcode{\_\_sub\_\_}}{\emph{other}}{}
This method will subtract 2 UInt.
We override this operator to be able to write operations more easily
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{other}} ({\hyperref[datatypes.integers:module\string-datatypes.integers.UInt]{\crossref{\emph{\texttt{UInt}}}}}) -- Right Operand

\item[{Returns}] \leavevmode
the difference of the two UInt

\item[{Return type}] \leavevmode
{\hyperref[datatypes.integers:module\string-datatypes.integers.UInt]{\crossref{UInt}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{debug\_showValue() (datatypes.integers.UInt.UInt method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.UInt.UInt.debug_showValue}\pysiglinewithargsret{\bfcode{debug\_showValue}}{}{}
This method is for debug purposes only, it will reveal the integer value of the UInt
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
an integer, the value of the UInt

\item[{Return type}] \leavevmode
integer

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\paragraph{datatypes.integers.UInt8 module}
\label{datatypes.integers:datatypes-integers-uint8-module}\label{datatypes.integers:module-datatypes.integers.UInt8}\index{datatypes.integers.UInt8 (module)}\index{UInt8 (class in datatypes.integers.UInt8)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.UInt8.UInt8}\pysiglinewithargsret{\strong{class }\code{datatypes.integers.UInt8.}\bfcode{UInt8}}{\emph{value=0}, \emph{bits=None}, \emph{randomize=False}}{}
Unsigned integer made from an array of 8 Bits. (from 0 to 255)
We chose a convention for our arrays of bits :
when we initiate a byte, the first bit of the array is the Most Significant Bit.
The last one is the Least Significant Bit.
Thus, bits{[}0{]} = MSB, bits{[}bits.length(){]} = LSB
Please note that this class can also be used to represent characters for example.
Since we cannot access the data, its meaning is irrelevant to us, therefore UInt8 might as well be considered as Char
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\textbf{\texttt{InstantiationError}} -- if the array is too long/short

\end{description}\end{quote}
\index{\_\_abs\_\_() (datatypes.integers.UInt8.UInt8 method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.UInt8.UInt8.__abs__}\pysiglinewithargsret{\bfcode{\_\_abs\_\_}}{}{}
return the absolute value which is itself
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
the absolute value (itself)

\item[{Return type}] \leavevmode
{\hyperref[datatypes.integers:datatypes.integers.UInt8.UInt8]{\crossref{UInt8}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_add\_\_() (datatypes.integers.UInt8.UInt8 method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.UInt8.UInt8.__add__}\pysiglinewithargsret{\bfcode{\_\_add\_\_}}{\emph{other}}{}
This method will add 2 UInt8.
We override this operator to be able to write operations more easily
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{other}} ({\hyperref[datatypes.integers:datatypes.integers.UInt8.UInt8]{\crossref{\emph{\texttt{UInt8}}}}}) -- Right Operand

\item[{Returns}] \leavevmode
the sum of the two UInt8

\item[{Return type}] \leavevmode
{\hyperref[datatypes.integers:datatypes.integers.UInt8.UInt8]{\crossref{UInt8}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_and\_\_() (datatypes.integers.UInt8.UInt8 method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.UInt8.UInt8.__and__}\pysiglinewithargsret{\bfcode{\_\_and\_\_}}{\emph{other}}{}
bitwise AND operation, returns an UInt8
We override this operator to be able to write operations more easily
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{other}} ({\hyperref[datatypes.integers:datatypes.integers.UInt8.UInt8]{\crossref{\emph{\texttt{UInt8}}}}}) -- Right Operand

\item[{Returns}] \leavevmode
bitwise AND operation, returns an UInt8

\item[{Return type}] \leavevmode
{\hyperref[datatypes.integers:datatypes.integers.UInt8.UInt8]{\crossref{UInt8}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_div\_\_() (datatypes.integers.UInt8.UInt8 method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.UInt8.UInt8.__div__}\pysiglinewithargsret{\bfcode{\_\_div\_\_}}{\emph{other}}{}
This method will divide 2 UInt8.
We override this operator to be able to write operations more easily
Note that by convention, the result will always be rounded towards 0
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{other}} ({\hyperref[datatypes.integers:datatypes.integers.UInt8.UInt8]{\crossref{\emph{\texttt{UInt8}}}}}) -- Right Operand

\item[{Returns}] \leavevmode
the result of division of the two UInt8

\item[{Return type}] \leavevmode
{\hyperref[datatypes.integers:datatypes.integers.UInt8.UInt8]{\crossref{UInt8}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_eq\_\_() (datatypes.integers.UInt8.UInt8 method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.UInt8.UInt8.__eq__}\pysiglinewithargsret{\bfcode{\_\_eq\_\_}}{\emph{other}}{}
test if two UInt8 are equal
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{other}} ({\hyperref[datatypes.integers:datatypes.integers.UInt8.UInt8]{\crossref{\emph{\texttt{UInt8}}}}}) -- UInt8 to compare

\item[{Returns}] \leavevmode
True or False, in form of a CryptoBit or a PlainBit

\item[{Return type}] \leavevmode
CryptoBit or PlainBit

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_ge\_\_() (datatypes.integers.UInt8.UInt8 method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.UInt8.UInt8.__ge__}\pysiglinewithargsret{\bfcode{\_\_ge\_\_}}{\emph{other}}{}
test if an UInt8 is greater or equal than/to another one
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{other}} ({\hyperref[datatypes.integers:datatypes.integers.UInt8.UInt8]{\crossref{\emph{\texttt{UInt8}}}}}) -- UInt8 to compare

\item[{Returns}] \leavevmode
CryptoBit or PlainBit (true or false)

\item[{Return type}] \leavevmode
CryptoBit or PlainBit

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_gt\_\_() (datatypes.integers.UInt8.UInt8 method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.UInt8.UInt8.__gt__}\pysiglinewithargsret{\bfcode{\_\_gt\_\_}}{\emph{other}}{}
test if an UInt8 is greater than another one
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{other}} ({\hyperref[datatypes.integers:datatypes.integers.UInt8.UInt8]{\crossref{\emph{\texttt{UInt8}}}}}) -- UInt8 to compare

\item[{Returns}] \leavevmode
CryptoBit or PlainBit (true or false)

\item[{Return type}] \leavevmode
CryptoBit or PlainBit

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_invert\_\_() (datatypes.integers.UInt8.UInt8 method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.UInt8.UInt8.__invert__}\pysiglinewithargsret{\bfcode{\_\_invert\_\_}}{}{}
returns the one's complement UInt8
We override this operator to be able to write operations more easily
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
the one's complement UInt8

\item[{Return type}] \leavevmode
{\hyperref[datatypes.integers:datatypes.integers.UInt8.UInt8]{\crossref{UInt8}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_le\_\_() (datatypes.integers.UInt8.UInt8 method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.UInt8.UInt8.__le__}\pysiglinewithargsret{\bfcode{\_\_le\_\_}}{\emph{other}}{}
test if an UInt8 is lesser or equal than/to another one
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{other}} ({\hyperref[datatypes.integers:datatypes.integers.UInt8.UInt8]{\crossref{\emph{\texttt{UInt8}}}}}) -- UInt8 to compare

\item[{Returns}] \leavevmode
CryptoBit or PlainBit (true or false)

\item[{Return type}] \leavevmode
CryptoBit or PlainBit

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_len\_\_() (datatypes.integers.UInt8.UInt8 method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.UInt8.UInt8.__len__}\pysiglinewithargsret{\bfcode{\_\_len\_\_}}{}{}
returns the length of the array of bits of an UInt8 (which is always 8)
We override this operator to be able to write operations more easily
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
an integer, the size of the array of bits of UInt8 (which is 8)

\item[{Return type}] \leavevmode
integer

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_lshift\_\_() (datatypes.integers.UInt8.UInt8 method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.UInt8.UInt8.__lshift__}\pysiglinewithargsret{\bfcode{\_\_lshift\_\_}}{\emph{other}}{}
returns an UInt8 that its bits were shifted to the left
We override this operator to be able to write operations more easily
Note that this operation performs an arithmetic shift and not a binary shift
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{other}} (\emph{\texttt{integer}}) -- integer to know how much we shift

\item[{Returns}] \leavevmode
an UInt8, its bits were shifted to the left

\item[{Return type}] \leavevmode
{\hyperref[datatypes.integers:datatypes.integers.UInt8.UInt8]{\crossref{UInt8}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_lt\_\_() (datatypes.integers.UInt8.UInt8 method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.UInt8.UInt8.__lt__}\pysiglinewithargsret{\bfcode{\_\_lt\_\_}}{\emph{other}}{}
test if an UInt8 is lesser than another one
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{other}} ({\hyperref[datatypes.integers:datatypes.integers.UInt8.UInt8]{\crossref{\emph{\texttt{UInt8}}}}}) -- UInt8 to compare

\item[{Returns}] \leavevmode
CryptoBit or PlainBit (true or false)

\item[{Return type}] \leavevmode
CryptoBit or PlainBit

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_mod\_\_() (datatypes.integers.UInt8.UInt8 method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.UInt8.UInt8.__mod__}\pysiglinewithargsret{\bfcode{\_\_mod\_\_}}{\emph{other}}{}
This method will return the remainder of the division between 2 UInt8.
We override this operator to be able to write operations more easily
Note that by convention : The result will always be positive
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{other}} ({\hyperref[datatypes.integers:datatypes.integers.UInt8.UInt8]{\crossref{\emph{\texttt{UInt8}}}}}) -- Right Operand

\item[{Returns}] \leavevmode
the remainder of the division between two UInt8

\item[{Return type}] \leavevmode
{\hyperref[datatypes.integers:datatypes.integers.UInt8.UInt8]{\crossref{UInt8}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_mul\_\_() (datatypes.integers.UInt8.UInt8 method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.UInt8.UInt8.__mul__}\pysiglinewithargsret{\bfcode{\_\_mul\_\_}}{\emph{other}}{}
This method will multiply 2 UInt8.
We override this operator to be able to write operations more easily
The multiplication seems to work fine, however there may be a problem in the addition of two UInt
Since the addition od two UInt is used in this method there may be some error
see addition of UInts of different sizes.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{other}} ({\hyperref[datatypes.integers:datatypes.integers.UInt8.UInt8]{\crossref{\emph{\texttt{UInt8}}}}}) -- Right Operand

\item[{Returns}] \leavevmode
the product of the two UInt8 which is an UInt

\item[{Return type}] \leavevmode
{\hyperref[datatypes.integers:module\string-datatypes.integers.UInt]{\crossref{UInt}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_neg\_\_() (datatypes.integers.UInt8.UInt8 method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.UInt8.UInt8.__neg__}\pysiglinewithargsret{\bfcode{\_\_neg\_\_}}{}{}
raise RuntimeError
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
RuntimeErro

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_or\_\_() (datatypes.integers.UInt8.UInt8 method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.UInt8.UInt8.__or__}\pysiglinewithargsret{\bfcode{\_\_or\_\_}}{\emph{other}}{}
bitwise OR operation, returns an UInt8
We override this operator to be able to write operations more easily
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{other}} ({\hyperref[datatypes.integers:datatypes.integers.UInt8.UInt8]{\crossref{\emph{\texttt{UInt8}}}}}) -- Right Operand

\item[{Returns}] \leavevmode
bitwise OR operation, returns an UInt8

\item[{Return type}] \leavevmode
{\hyperref[datatypes.integers:datatypes.integers.UInt8.UInt8]{\crossref{UInt8}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_repr\_\_() (datatypes.integers.UInt8.UInt8 method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.UInt8.UInt8.__repr__}\pysiglinewithargsret{\bfcode{\_\_repr\_\_}}{}{}
Return representation of UInt8
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
integer, the value of the UInt8

\item[{Return type}] \leavevmode
integer

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_rshift\_\_() (datatypes.integers.UInt8.UInt8 method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.UInt8.UInt8.__rshift__}\pysiglinewithargsret{\bfcode{\_\_rshift\_\_}}{\emph{other}}{}
returns an UInt8 that its bits were shifted to the right
We override this operator to be able to write operations more easily
Note that this operation performs an arithmetic shift and not a binary shift, this means
that the new bit inserted will be equal to the MSB
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{other}} (\emph{\texttt{integer}}) -- integer to know how much we shift

\item[{Returns}] \leavevmode
an UInt8, its bits were shifted to the right

\item[{Return type}] \leavevmode
{\hyperref[datatypes.integers:datatypes.integers.UInt8.UInt8]{\crossref{UInt8}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_sub\_\_() (datatypes.integers.UInt8.UInt8 method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.UInt8.UInt8.__sub__}\pysiglinewithargsret{\bfcode{\_\_sub\_\_}}{\emph{other}}{}
This method will subtract 2 UInt8.
We override this operator to be able to write operations more easily
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{other}} ({\hyperref[datatypes.integers:datatypes.integers.UInt8.UInt8]{\crossref{\emph{\texttt{UInt8}}}}}) -- Right Operand

\item[{Returns}] \leavevmode
the difference of the two UInt8

\item[{Return type}] \leavevmode
{\hyperref[datatypes.integers:datatypes.integers.UInt8.UInt8]{\crossref{UInt8}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_xor\_\_() (datatypes.integers.UInt8.UInt8 method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.UInt8.UInt8.__xor__}\pysiglinewithargsret{\bfcode{\_\_xor\_\_}}{\emph{other}}{}
bitwise XOR operation, returns an UInt8
We override this operator to be able to write operations more easily
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{other}} ({\hyperref[datatypes.integers:datatypes.integers.UInt8.UInt8]{\crossref{\emph{\texttt{UInt8}}}}}) -- Right Operand

\item[{Returns}] \leavevmode
bitwise XOR operation, returns an UInt8

\item[{Return type}] \leavevmode
{\hyperref[datatypes.integers:datatypes.integers.UInt8.UInt8]{\crossref{UInt8}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{debug\_showValue() (datatypes.integers.UInt8.UInt8 method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.UInt8.UInt8.debug_showValue}\pysiglinewithargsret{\bfcode{debug\_showValue}}{}{}
This method is for debug purposes only, it will reveal the integer value of the UInt8
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
an integer, the value of the UInt8

\item[{Return type}] \leavevmode
integer

\end{description}\end{quote}

\end{fulllineitems}

\index{decrypt() (datatypes.integers.UInt8.UInt8 method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.UInt8.UInt8.decrypt}\pysiglinewithargsret{\bfcode{decrypt}}{}{}
This method makes every CryptoBit into PlainBit

\end{fulllineitems}

\index{encrypt() (datatypes.integers.UInt8.UInt8 method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.UInt8.UInt8.encrypt}\pysiglinewithargsret{\bfcode{encrypt}}{}{}
This method makes every PlainBit into CryptoBit

\end{fulllineitems}

\index{showValue() (datatypes.integers.UInt8.UInt8 method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.UInt8.UInt8.showValue}\pysiglinewithargsret{\bfcode{showValue}}{}{}
This method will show the `fake' value. It will read the value of the CryptoBit
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
an integer, the `fake' value of the UInt8

\item[{Return type}] \leavevmode
integer

\end{description}\end{quote}

\end{fulllineitems}

\index{toInt8() (datatypes.integers.UInt8.UInt8 method)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.UInt8.UInt8.toInt8}\pysiglinewithargsret{\bfcode{toInt8}}{}{}
returns the value of integer as Signed Integer (Int8)
overflow might occur, if this is the case, the variable testOverflow of the returned Integer will be set to true
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
value of integer as Int8

\item[{Return type}] \leavevmode
{\hyperref[datatypes.integers:datatypes.integers.Int8.Int8]{\crossref{Int8}}}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\paragraph{datatypes.integers.Utility module}
\label{datatypes.integers:module-datatypes.integers.Utility}\label{datatypes.integers:datatypes-integers-utility-module}\index{datatypes.integers.Utility (module)}\index{completeAddOnOneBit() (in module datatypes.integers.Utility)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.Utility.completeAddOnOneBit}\pysiglinewithargsret{\code{datatypes.integers.Utility.}\bfcode{completeAddOnOneBit}}{\emph{firstBit}, \emph{secondBit}, \emph{carry}}{}
This method will add 2 Bits.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{firstBit}} (\emph{\texttt{Bit (CryptoBit or PlainBit)}}) -- Left Operand

\item {} 
\textbf{\texttt{secondBit}} (\emph{\texttt{Bit (CryptoBit or PlainBit)}}) -- Right Operand

\item {} 
\textbf{\texttt{carry}} (\emph{\texttt{Bit (CryptoBit or PlainBit)}}) -- The carry for the addition. A Bit (CryptoBit or PlainBit)

\end{itemize}

\item[{Returns}] \leavevmode
A bit : the result of XOR between the two Bits. And a Bit that is the carry

\item[{Return type}] \leavevmode
Bit, Bit

\end{description}\end{quote}

\end{fulllineitems}

\index{completeSubOnOneBit() (in module datatypes.integers.Utility)}

\begin{fulllineitems}
\phantomsection\label{datatypes.integers:datatypes.integers.Utility.completeSubOnOneBit}\pysiglinewithargsret{\code{datatypes.integers.Utility.}\bfcode{completeSubOnOneBit}}{\emph{minuend}, \emph{subtrahend}, \emph{borrowIn}}{}
This method will subtract 2 Bits.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{minuend}} (\emph{\texttt{Bit (CryptoBit or PlainBit)}}) -- Left Operand

\item {} 
\textbf{\texttt{subtrahend}} (\emph{\texttt{Bit (CryptoBit or PlainBit)}}) -- Right Operand

\item {} 
\textbf{\texttt{borrowIn}} (\emph{\texttt{Bit (CryptoBit or PlainBit)}}) -- The borrowIn for the subtraction. A Bit (CryptoBit or PlainBit)

\end{itemize}

\item[{Returns}] \leavevmode
A bit : the result of XOR between the two Bits. And a Bit that is the BorrowIn

\item[{Return type}] \leavevmode
Bit, Bit

\end{description}\end{quote}

\end{fulllineitems}



\section{demo package}
\label{demo::doc}\label{demo:demo-package}

\subsection{Submodules}
\label{demo:submodules}

\subsection{demo.ImageUtils module}
\label{demo:module-demo.ImageUtils}\label{demo:demo-imageutils-module}\index{demo.ImageUtils (module)}\index{decode() (in module demo.ImageUtils)}

\begin{fulllineitems}
\phantomsection\label{demo:demo.ImageUtils.decode}\pysiglinewithargsret{\code{demo.ImageUtils.}\bfcode{decode}}{\emph{pixels}, \emph{path}}{}
This function will take a 2D Matrix of 3-sized tuple UInt8 and return the corresponding image
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{pixels}} (\emph{\texttt{2D Matrix of UInt8 tuple of size 3}}) -- This is the pixels data

\item {} 
\textbf{\texttt{path}} (\emph{\texttt{String}}) -- This is the path that the image will be saved on

\end{itemize}

\item[{Returns}] \leavevmode
Pixels Matrix encoded with our datatypes

\item[{Return type}] \leavevmode
2D Matrix of UInt8 tuple of size 3

\end{description}\end{quote}

\end{fulllineitems}

\index{decrypt() (in module demo.ImageUtils)}

\begin{fulllineitems}
\phantomsection\label{demo:demo.ImageUtils.decrypt}\pysiglinewithargsret{\code{demo.ImageUtils.}\bfcode{decrypt}}{\emph{pixels}}{}
This function will take an encrypted 2D Matrix of 3-sized tuple UInt8 and decrypt it
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{pixels}} (\emph{\texttt{2D Matrix of UInt8 tuple of size 3}}) -- This is the pixels data

\item[{Returns}] \leavevmode
Decrypted Pixels Matrix encoded with our datatypes

\item[{Return type}] \leavevmode
2D Matrix of UInt8 tuple of size 3

\end{description}\end{quote}

\end{fulllineitems}

\index{dump() (in module demo.ImageUtils)}

\begin{fulllineitems}
\phantomsection\label{demo:demo.ImageUtils.dump}\pysiglinewithargsret{\code{demo.ImageUtils.}\bfcode{dump}}{\emph{data}, \emph{path}}{}
This will write a python object to a file, in our case we will use it to transfer the data between bob and alice
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} (\emph{\texttt{Python Object}}) -- The python object to save

\item {} 
\textbf{\texttt{path}} (\emph{\texttt{String}}) -- Path to save the object

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{encode() (in module demo.ImageUtils)}

\begin{fulllineitems}
\phantomsection\label{demo:demo.ImageUtils.encode}\pysiglinewithargsret{\code{demo.ImageUtils.}\bfcode{encode}}{\emph{path}}{}
This function will take an RGB image of bit depth 24 and encode all of its data into our datatypes
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{path}} (\emph{\texttt{String}}) -- This is the path to the image, image must be of type RGB and and a 24 bit depth

\item[{Returns}] \leavevmode
Pixels Matrix encoded with our datatypes

\item[{Return type}] \leavevmode
2D Matrix of UInt8 tuple of size 3

\end{description}\end{quote}

\end{fulllineitems}

\index{encrypt() (in module demo.ImageUtils)}

\begin{fulllineitems}
\phantomsection\label{demo:demo.ImageUtils.encrypt}\pysiglinewithargsret{\code{demo.ImageUtils.}\bfcode{encrypt}}{\emph{pixels}}{}
This function will take a 2D Matrix of 3-sized tuple UInt8 and encrypt it
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{pixels}} (\emph{\texttt{2D Matrix of UInt8 tuple of size 3}}) -- This is the pixels data

\item[{Returns}] \leavevmode
Encrypted Pixels Matrix encoded with our datatypes

\item[{Return type}] \leavevmode
2D Matrix of UInt8 tuple of size 3

\end{description}\end{quote}

\end{fulllineitems}

\index{load() (in module demo.ImageUtils)}

\begin{fulllineitems}
\phantomsection\label{demo:demo.ImageUtils.load}\pysiglinewithargsret{\code{demo.ImageUtils.}\bfcode{load}}{\emph{path}}{}
This function will read a python object written with pickel from a file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{path}} (\emph{\texttt{String}}) -- Path to file to read

\item[{Returns}] \leavevmode
Python object retrieved from the file

\item[{Return type}] \leavevmode
Python Object

\end{description}\end{quote}

\end{fulllineitems}

\index{negate() (in module demo.ImageUtils)}

\begin{fulllineitems}
\phantomsection\label{demo:demo.ImageUtils.negate}\pysiglinewithargsret{\code{demo.ImageUtils.}\bfcode{negate}}{\emph{pixels}}{}
This function will take a 2D Matrix of 3-sized tuple UInt8 and invert its values
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{pixels}} (\emph{\texttt{2D Matrix of UInt8 tuple of size 3}}) -- This is the pixels data

\item[{Returns}] \leavevmode
Negated Pixels Matrix

\item[{Return type}] \leavevmode
2D Matrix of UInt8 tuple of size 3

\end{description}\end{quote}

\end{fulllineitems}



\section{main module}
\label{main:module-main}\label{main:main-module}\label{main::doc}\index{main (module)}\index{result (in module main)}

\begin{fulllineitems}
\phantomsection\label{main:main.result}\pysigline{\code{main.}\bfcode{result}\strong{ = \textless{}unittest.runner.TextTestResult run=31 errors=0 failures=3\textgreater{}}}
int1 = UInt8(value=54)
int2 = UInt8(value=19)

int3 = int1 * int2

int3.debug\_showValue()

\end{fulllineitems}



\section{testing package}
\label{testing:testing-package}\label{testing::doc}

\subsection{Submodules}
\label{testing:submodules}

\subsection{testing.TestBitsMethods module}
\label{testing:testing-testbitsmethods-module}\label{testing:module-testing.TestBitsMethods}\index{testing.TestBitsMethods (module)}\index{TestBitsMethods (class in testing.TestBitsMethods)}

\begin{fulllineitems}
\phantomsection\label{testing:testing.TestBitsMethods.TestBitsMethods}\pysiglinewithargsret{\strong{class }\code{testing.TestBitsMethods.}\bfcode{TestBitsMethods}}{\emph{methodName='runTest'}}{}
Bases: \code{unittest.case.TestCase}

Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.
\index{test\_and() (testing.TestBitsMethods.TestBitsMethods method)}

\begin{fulllineitems}
\phantomsection\label{testing:testing.TestBitsMethods.TestBitsMethods.test_and}\pysiglinewithargsret{\bfcode{test\_and}}{}{}
\end{fulllineitems}

\index{test\_or() (testing.TestBitsMethods.TestBitsMethods method)}

\begin{fulllineitems}
\phantomsection\label{testing:testing.TestBitsMethods.TestBitsMethods.test_or}\pysiglinewithargsret{\bfcode{test\_or}}{}{}
\end{fulllineitems}

\index{test\_xor() (testing.TestBitsMethods.TestBitsMethods method)}

\begin{fulllineitems}
\phantomsection\label{testing:testing.TestBitsMethods.TestBitsMethods.test_xor}\pysiglinewithargsret{\bfcode{test\_xor}}{}{}
\end{fulllineitems}


\end{fulllineitems}



\subsection{testing.TestInt8Methods module}
\label{testing:testing-testint8methods-module}\label{testing:module-testing.TestInt8Methods}\index{testing.TestInt8Methods (module)}\index{TestInt8Methods (class in testing.TestInt8Methods)}

\begin{fulllineitems}
\phantomsection\label{testing:testing.TestInt8Methods.TestInt8Methods}\pysiglinewithargsret{\strong{class }\code{testing.TestInt8Methods.}\bfcode{TestInt8Methods}}{\emph{methodName='runTest'}}{}
Bases: \code{unittest.case.TestCase}

Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.
\index{setUp() (testing.TestInt8Methods.TestInt8Methods method)}

\begin{fulllineitems}
\phantomsection\label{testing:testing.TestInt8Methods.TestInt8Methods.setUp}\pysiglinewithargsret{\bfcode{setUp}}{}{}
\end{fulllineitems}

\index{test\_int8\_abs() (testing.TestInt8Methods.TestInt8Methods method)}

\begin{fulllineitems}
\phantomsection\label{testing:testing.TestInt8Methods.TestInt8Methods.test_int8_abs}\pysiglinewithargsret{\bfcode{test\_int8\_abs}}{}{}
\end{fulllineitems}

\index{test\_int8\_addition() (testing.TestInt8Methods.TestInt8Methods method)}

\begin{fulllineitems}
\phantomsection\label{testing:testing.TestInt8Methods.TestInt8Methods.test_int8_addition}\pysiglinewithargsret{\bfcode{test\_int8\_addition}}{}{}
\end{fulllineitems}

\index{test\_int8\_debugshowValue() (testing.TestInt8Methods.TestInt8Methods method)}

\begin{fulllineitems}
\phantomsection\label{testing:testing.TestInt8Methods.TestInt8Methods.test_int8_debugshowValue}\pysiglinewithargsret{\bfcode{test\_int8\_debugshowValue}}{}{}
\end{fulllineitems}

\index{test\_int8\_division() (testing.TestInt8Methods.TestInt8Methods method)}

\begin{fulllineitems}
\phantomsection\label{testing:testing.TestInt8Methods.TestInt8Methods.test_int8_division}\pysiglinewithargsret{\bfcode{test\_int8\_division}}{}{}
\end{fulllineitems}

\index{test\_int8\_eq\_ne() (testing.TestInt8Methods.TestInt8Methods method)}

\begin{fulllineitems}
\phantomsection\label{testing:testing.TestInt8Methods.TestInt8Methods.test_int8_eq_ne}\pysiglinewithargsret{\bfcode{test\_int8\_eq\_ne}}{}{}
\end{fulllineitems}

\index{test\_int8\_ge() (testing.TestInt8Methods.TestInt8Methods method)}

\begin{fulllineitems}
\phantomsection\label{testing:testing.TestInt8Methods.TestInt8Methods.test_int8_ge}\pysiglinewithargsret{\bfcode{test\_int8\_ge}}{}{}
\end{fulllineitems}

\index{test\_int8\_gt() (testing.TestInt8Methods.TestInt8Methods method)}

\begin{fulllineitems}
\phantomsection\label{testing:testing.TestInt8Methods.TestInt8Methods.test_int8_gt}\pysiglinewithargsret{\bfcode{test\_int8\_gt}}{}{}
\end{fulllineitems}

\index{test\_int8\_le() (testing.TestInt8Methods.TestInt8Methods method)}

\begin{fulllineitems}
\phantomsection\label{testing:testing.TestInt8Methods.TestInt8Methods.test_int8_le}\pysiglinewithargsret{\bfcode{test\_int8\_le}}{}{}
\end{fulllineitems}

\index{test\_int8\_lshift() (testing.TestInt8Methods.TestInt8Methods method)}

\begin{fulllineitems}
\phantomsection\label{testing:testing.TestInt8Methods.TestInt8Methods.test_int8_lshift}\pysiglinewithargsret{\bfcode{test\_int8\_lshift}}{}{}
\end{fulllineitems}

\index{test\_int8\_lt() (testing.TestInt8Methods.TestInt8Methods method)}

\begin{fulllineitems}
\phantomsection\label{testing:testing.TestInt8Methods.TestInt8Methods.test_int8_lt}\pysiglinewithargsret{\bfcode{test\_int8\_lt}}{}{}
\end{fulllineitems}

\index{test\_int8\_mod() (testing.TestInt8Methods.TestInt8Methods method)}

\begin{fulllineitems}
\phantomsection\label{testing:testing.TestInt8Methods.TestInt8Methods.test_int8_mod}\pysiglinewithargsret{\bfcode{test\_int8\_mod}}{}{}
\end{fulllineitems}

\index{test\_int8\_rshift() (testing.TestInt8Methods.TestInt8Methods method)}

\begin{fulllineitems}
\phantomsection\label{testing:testing.TestInt8Methods.TestInt8Methods.test_int8_rshift}\pysiglinewithargsret{\bfcode{test\_int8\_rshift}}{}{}
\end{fulllineitems}

\index{test\_int8\_subtraction() (testing.TestInt8Methods.TestInt8Methods method)}

\begin{fulllineitems}
\phantomsection\label{testing:testing.TestInt8Methods.TestInt8Methods.test_int8_subtraction}\pysiglinewithargsret{\bfcode{test\_int8\_subtraction}}{}{}
\end{fulllineitems}


\end{fulllineitems}



\subsection{testing.TestNoise module}
\label{testing:testing-testnoise-module}

\subsection{testing.TestUInt8Methods module}
\label{testing:module-testing.TestUInt8Methods}\label{testing:testing-testuint8methods-module}\index{testing.TestUInt8Methods (module)}\index{TestUInt8Methods (class in testing.TestUInt8Methods)}

\begin{fulllineitems}
\phantomsection\label{testing:testing.TestUInt8Methods.TestUInt8Methods}\pysiglinewithargsret{\strong{class }\code{testing.TestUInt8Methods.}\bfcode{TestUInt8Methods}}{\emph{methodName='runTest'}}{}
Bases: \code{unittest.case.TestCase}

Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.
\index{setUp() (testing.TestUInt8Methods.TestUInt8Methods method)}

\begin{fulllineitems}
\phantomsection\label{testing:testing.TestUInt8Methods.TestUInt8Methods.setUp}\pysiglinewithargsret{\bfcode{setUp}}{}{}
\end{fulllineitems}

\index{test\_uint8\_addition() (testing.TestUInt8Methods.TestUInt8Methods method)}

\begin{fulllineitems}
\phantomsection\label{testing:testing.TestUInt8Methods.TestUInt8Methods.test_uint8_addition}\pysiglinewithargsret{\bfcode{test\_uint8\_addition}}{}{}
\end{fulllineitems}

\index{test\_uint8\_debugshowValue() (testing.TestUInt8Methods.TestUInt8Methods method)}

\begin{fulllineitems}
\phantomsection\label{testing:testing.TestUInt8Methods.TestUInt8Methods.test_uint8_debugshowValue}\pysiglinewithargsret{\bfcode{test\_uint8\_debugshowValue}}{}{}
\end{fulllineitems}

\index{test\_uint8\_division() (testing.TestUInt8Methods.TestUInt8Methods method)}

\begin{fulllineitems}
\phantomsection\label{testing:testing.TestUInt8Methods.TestUInt8Methods.test_uint8_division}\pysiglinewithargsret{\bfcode{test\_uint8\_division}}{}{}
\end{fulllineitems}

\index{test\_uint8\_eq\_ne() (testing.TestUInt8Methods.TestUInt8Methods method)}

\begin{fulllineitems}
\phantomsection\label{testing:testing.TestUInt8Methods.TestUInt8Methods.test_uint8_eq_ne}\pysiglinewithargsret{\bfcode{test\_uint8\_eq\_ne}}{}{}
\end{fulllineitems}

\index{test\_uint8\_ge() (testing.TestUInt8Methods.TestUInt8Methods method)}

\begin{fulllineitems}
\phantomsection\label{testing:testing.TestUInt8Methods.TestUInt8Methods.test_uint8_ge}\pysiglinewithargsret{\bfcode{test\_uint8\_ge}}{}{}
\end{fulllineitems}

\index{test\_uint8\_gt() (testing.TestUInt8Methods.TestUInt8Methods method)}

\begin{fulllineitems}
\phantomsection\label{testing:testing.TestUInt8Methods.TestUInt8Methods.test_uint8_gt}\pysiglinewithargsret{\bfcode{test\_uint8\_gt}}{}{}
\end{fulllineitems}

\index{test\_uint8\_le() (testing.TestUInt8Methods.TestUInt8Methods method)}

\begin{fulllineitems}
\phantomsection\label{testing:testing.TestUInt8Methods.TestUInt8Methods.test_uint8_le}\pysiglinewithargsret{\bfcode{test\_uint8\_le}}{}{}
\end{fulllineitems}

\index{test\_uint8\_lshift() (testing.TestUInt8Methods.TestUInt8Methods method)}

\begin{fulllineitems}
\phantomsection\label{testing:testing.TestUInt8Methods.TestUInt8Methods.test_uint8_lshift}\pysiglinewithargsret{\bfcode{test\_uint8\_lshift}}{}{}
\end{fulllineitems}

\index{test\_uint8\_lt() (testing.TestUInt8Methods.TestUInt8Methods method)}

\begin{fulllineitems}
\phantomsection\label{testing:testing.TestUInt8Methods.TestUInt8Methods.test_uint8_lt}\pysiglinewithargsret{\bfcode{test\_uint8\_lt}}{}{}
\end{fulllineitems}

\index{test\_uint8\_mod() (testing.TestUInt8Methods.TestUInt8Methods method)}

\begin{fulllineitems}
\phantomsection\label{testing:testing.TestUInt8Methods.TestUInt8Methods.test_uint8_mod}\pysiglinewithargsret{\bfcode{test\_uint8\_mod}}{}{}
\end{fulllineitems}

\index{test\_uint8\_rshift() (testing.TestUInt8Methods.TestUInt8Methods method)}

\begin{fulllineitems}
\phantomsection\label{testing:testing.TestUInt8Methods.TestUInt8Methods.test_uint8_rshift}\pysiglinewithargsret{\bfcode{test\_uint8\_rshift}}{}{}
\end{fulllineitems}

\index{test\_uint8\_subtraction() (testing.TestUInt8Methods.TestUInt8Methods method)}

\begin{fulllineitems}
\phantomsection\label{testing:testing.TestUInt8Methods.TestUInt8Methods.test_uint8_subtraction}\pysiglinewithargsret{\bfcode{test\_uint8\_subtraction}}{}{}
\end{fulllineitems}


\end{fulllineitems}



\subsection{testing.TestUIntMethods module}
\label{testing:testing-testuintmethods-module}\label{testing:module-testing.TestUIntMethods}\index{testing.TestUIntMethods (module)}\index{TestUIntMethods (class in testing.TestUIntMethods)}

\begin{fulllineitems}
\phantomsection\label{testing:testing.TestUIntMethods.TestUIntMethods}\pysiglinewithargsret{\strong{class }\code{testing.TestUIntMethods.}\bfcode{TestUIntMethods}}{\emph{methodName='runTest'}}{}
Bases: \code{unittest.case.TestCase}

Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.
\index{setUp() (testing.TestUIntMethods.TestUIntMethods method)}

\begin{fulllineitems}
\phantomsection\label{testing:testing.TestUIntMethods.TestUIntMethods.setUp}\pysiglinewithargsret{\bfcode{setUp}}{}{}
\end{fulllineitems}

\index{test\_uint\_addition() (testing.TestUIntMethods.TestUIntMethods method)}

\begin{fulllineitems}
\phantomsection\label{testing:testing.TestUIntMethods.TestUIntMethods.test_uint_addition}\pysiglinewithargsret{\bfcode{test\_uint\_addition}}{}{}
\end{fulllineitems}

\index{test\_uint\_debugshowValue() (testing.TestUIntMethods.TestUIntMethods method)}

\begin{fulllineitems}
\phantomsection\label{testing:testing.TestUIntMethods.TestUIntMethods.test_uint_debugshowValue}\pysiglinewithargsret{\bfcode{test\_uint\_debugshowValue}}{}{}
\end{fulllineitems}

\index{test\_uint\_subtraction() (testing.TestUIntMethods.TestUIntMethods method)}

\begin{fulllineitems}
\phantomsection\label{testing:testing.TestUIntMethods.TestUIntMethods.test_uint_subtraction}\pysiglinewithargsret{\bfcode{test\_uint\_subtraction}}{}{}
\end{fulllineitems}


\end{fulllineitems}



\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{d}
\item {\texttt{datatypes.bits.Bit}}, \pageref{datatypes.bits:module-datatypes.bits.Bit}
\item {\texttt{datatypes.bits.errors.BitwiseOperationError}}, \pageref{datatypes.bits.errors:module-datatypes.bits.errors.BitwiseOperationError}
\item {\texttt{datatypes.bits.errors.InstantiationError}}, \pageref{datatypes.bits.errors:module-datatypes.bits.errors.InstantiationError}
\item {\texttt{datatypes.bits.errors.OpNotAllowedError}}, \pageref{datatypes.bits.errors:module-datatypes.bits.errors.OpNotAllowedError}
\item {\texttt{datatypes.integers.error.BadRightOperand}}, \pageref{datatypes.integers.error:module-datatypes.integers.error.BadRightOperand}
\item {\texttt{datatypes.integers.error.OverflowError}}, \pageref{datatypes.integers.error:module-datatypes.integers.error.OverflowError}
\item {\texttt{datatypes.integers.Int8}}, \pageref{datatypes.integers:module-datatypes.integers.Int8}
\item {\texttt{datatypes.integers.UInt}}, \pageref{datatypes.integers:module-datatypes.integers.UInt}
\item {\texttt{datatypes.integers.UInt8}}, \pageref{datatypes.integers:module-datatypes.integers.UInt8}
\item {\texttt{datatypes.integers.Utility}}, \pageref{datatypes.integers:module-datatypes.integers.Utility}
\item {\texttt{demo.ImageUtils}}, \pageref{demo:module-demo.ImageUtils}
\indexspace
\bigletter{m}
\item {\texttt{main}}, \pageref{main:module-main}
\indexspace
\bigletter{t}
\item {\texttt{testing.TestBitsMethods}}, \pageref{testing:module-testing.TestBitsMethods}
\item {\texttt{testing.TestInt8Methods}}, \pageref{testing:module-testing.TestInt8Methods}
\item {\texttt{testing.TestUInt8Methods}}, \pageref{testing:module-testing.TestUInt8Methods}
\item {\texttt{testing.TestUIntMethods}}, \pageref{testing:module-testing.TestUIntMethods}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
